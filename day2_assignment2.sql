-- day2_assignment
/*
Q2-1. 테이블 객체 - 외래 키 - 널(NULL)
Q2-2. 문자열 예시 - 문자셋
Q2-3. VARCHAR2 - CHARQ2-4. 키 제약조건 - 기본키 - 외래키
Q2-5. 무결성(Integrity) 제약조건 - 개체 무결성 - 참조 무결성
Q2-6. PK- Unique + Not null + Index
*/


--1-1
SELECT E.DEPTNO
	  ,TRUNC(AVG(E.SAL)) AS AVG_SAL
	  ,MAX(E.SAL) AS MAX_SAL
	  ,MIN(E.SAL) AS MIN_SAL
	  ,COUNT(E.DEPTNO) AS CNT
FROM EMP e ,dept D
WHERE e.DEPTNO =d.DEPTNO
GROUP BY e.DEPTNO
;

--1-2
SELECT E.JOB, 
	COUNT(*)
FROM EMP E
GROUP BY E.JOB 
HAVING COUNT(*) >= 3;


--1-3
SELECT  TO_CHAR(HIREDATE,'YYYY') AS HIREYEAR
	,DEPTNO 
	,COUNT(*) AS CNT
FROM EMP E
GROUP BY DEPTNO 
	,TO_CHAR(HIREDATE,'YYYY') 
ORDER BY TO_CHAR(HIREDATE,'YYYY') DESC
;


--1-4 추가수당을 받는 사원수와 받지 않는 수를 출력
SELECT 
	CASE WHEN E.COMM IS NOT NULL THEN 'Y' ELSE 'N'END AS EXIST_COMM
	,COUNT(*) AS CNT
FROM EMP E
GROUP BY CASE WHEN E.COMM IS NOT NULL THEN 'Y' ELSE 'N' END;
;


--1-5

SELECT d.DEPTNO 
	,TO_CHAR(e.HIREDATE,'YYYY') AS HYRE_YEAR
	,COUNT(*) AS CNT
	,MAX(E.SAL) AS MAX_SAL
	,SUM(E.SAL) AS SUM_SAL
	,AVG(E.SAL) AS AVG_SAL

FROM 
    EMP e
    JOIN DEPT d ON e.DEPTNO = d.DEPTNO
GROUP BY ROLLUP(d.DEPTNO, TO_CHAR(e.HIREDATE, 'YYYY'))
ORDER BY d.DEPTNO, TO_CHAR(e.HIREDATE, 'YYYY');


--2-1오라클

SELECT d.DEPTNO 
	,d.DNAME 
	,e.EMPNO 
	,e.ENAME 
	,e.SAL 
FROM DEPT d , EMP e
WHERE e.DEPTNO = d.DEPTNO 
AND sal >2000
;
--2-1표준sql

SELECT d.DEPTNO 
	,d.DNAME 
	,e.EMPNO 
	,e.ENAME 
	,e.SAL 
FROM EMP e JOIN DEPT d
 		ON (e.DEPTNO = d.DEPTNO)
AND sal >2000
;


--2-2
SELECT E.DEPTNO 
	,d.DNAME 
	,FLOOR(AVG(e.sal)) AS AVG_SAL
	,MAX(E.SAL) AS MAX_SAL
	,MIN(E.SAL) AS MIN_SAL
	,COUNT(*) 
FROM EMP E, DEPT d 
WHERE E.DEPTNO = D.DEPTNO 
GROUP BY E.DEPTNO , D.DNAME 
;


--2-3
SELECT d.DEPTNO 
	,d.DNAME 
	,e.EMPNO 
	,e.ENAME 
	,e.JOB 
	,e.SAL 
FROM EMP e, DEPT d 
WHERE e.DEPTNO (+) =d.DEPTNO 
;
--FROM DEPT d 
--RIGHT JOIN EMP e ON e.DEPTNO = d.DEPTNO 
--ORDER BY d.DEPTNO;


--2-4
SELECT D.DEPTNO
	  ,D.DNAME
	  ,E.EMPNO
	  ,E.ENAME
	  ,E.MGR 
	  ,E.SAL 
	  ,E.DEPTNO 
	  ,S.LOSAL 
	  ,S.HISAL 
	  ,S.GRADE 
	  ,E2.EMPNO AS MGR_EMPNO
	  ,E2.ENAME AS MGR_ENAME
FROM emp e, DEPT d , SALGRADE s , emp e2
WHERE e.DEPTNO  (+) = d.DEPTNO 
AND e.sal BETWEEN s.LOSAL (+) AND s.HISAL (+)
AND e.MGR  =e2.empno(+)
ORDER BY d.DEPTNO ,e.EMPNO 
;

---3-1

SELECT e.JOB 
	,e.EMPNO 
	,e.ENAME 
	,e.SAL 
	,d.DEPTNO 
	,d.DNAME 
FROM EMP e , DEPT d 
WHERE e.DEPTNO = d.DEPTNO 
AND job = (SELECT job FROM emp WHERE ename ='ALLEN')
;


--3-2
SELECT AVG(SAL) FROM EMP

SELECT E.EMPNO
	  ,E.ENAME 
	  ,D.DNAME 
	  ,E.HIREDATE 
	  ,D.LOC 
	  ,E.SAL 
	  ,S.GRADE 
FROM EMP e, DEPT d , SALGRADE s 
WHERE D.DEPTNO = E.DEPTNO 
AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+) 
AND E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY SAL DESC, EMPNO
;



--3-3여기서부터 다시보기***********************************

SELECT DISTINCT JOB FROM EMP WHERE DEPTNO = 30;
SELECT * FROM EMP WHERE DEPTNO = 10;

SELECT E.EMPNO 
	  ,E.ENAME 
	  ,E.JOB 
	  ,D.DEPTNO 
	  ,D.DNAME 
	  ,D.LOC 
FROM EMP e , DEPT d 
WHERE D.DEPTNO = E.DEPTNO 
AND JOB NOT IN (SELECT JOB FROM EMP WHERE DEPTNO = 30)
AND D.DEPTNO = 10;



--3-4
SELECT E.EMPNO 
	  ,E.ENAME 
	  ,E.SAL 
	  ,S.GRADE
FROM EMP e , DEPT d , SALGRADE s 
WHERE D.DEPTNO = E.DEPTNO 
AND E.SAL BETWEEN S.LOSAL (+) AND S.HISAL (+)
AND SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB = 'SALESMAN')
ORDER BY EMPNO
;


--3-5
SELECT E.EMPNO 
	  ,E.ENAME 
	  ,E.SAL 
	  ,S.GRADE
FROM EMP e , DEPT d , SALGRADE s 
WHERE D.DEPTNO = E.DEPTNO 
AND E.SAL BETWEEN S.LOSAL (+) AND S.HISAL (+)
AND SAL > ALL(SELECT SAL FROM EMP WHERE JOB = 'SALESMAN')
ORDER BY EMPNO
;

